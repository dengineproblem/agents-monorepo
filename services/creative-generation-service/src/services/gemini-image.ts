import { GoogleGenerativeAI } from '@google/generative-ai';
import { generateImagePrompt } from './imagePromptGenerator';

let genAI: GoogleGenerativeAI | null = null;

function getGeminiClient(): GoogleGenerativeAI {
  if (!genAI) {
    const apiKey = process.env.GEMINI_API_KEY;
    if (!apiKey) {
      throw new Error('GEMINI_API_KEY must be set in environment variables');
    }
    genAI = new GoogleGenerativeAI(apiKey);
  }
  return genAI;
}

/**
 * Генерация изображения через Gemini 3 Pro Image Preview
 * @param offer - Заголовок креатива
 * @param bullets - Буллеты
 * @param profits - Выгода
 * @param userPrompt4 - Пользовательский промпт для стилизации изображения (PROMPT4)
 * @param styleId - Выбранный стиль креатива
 * @param referenceImage - Референсное изображение (base64 или URL)
 * @param referenceImageType - Тип изображения ('base64' или 'url')
 * @param referenceImagePrompt - Описание того, как использовать референсное изображение
 * @returns Base64 изображение
 */
export async function generateCreativeImage(
  offer: string,
  bullets: string,
  profits: string,
  userPrompt4: string,
  styleId: 'modern_performance' | 'live_ugc' | 'visual_hook' | 'premium_minimal' | 'product_hero',
  referenceImage?: string,
  referenceImageType?: 'base64' | 'url',
  referenceImagePrompt?: string
): Promise<string> {
  try {
    const hasReferenceImage = !!referenceImage;

    console.log('[Gemini] Generating image prompt via LLM agent...');
    console.log('[Gemini] Style:', styleId);
    console.log('[Gemini] PROMPT4 length:', userPrompt4.length);

    // Генерируем промпт через LLM-агент
    const prompt = await generateImagePrompt(
      userPrompt4,
      styleId,
      offer,
      bullets,
      profits
    );

    // Если есть reference_image_prompt, добавляем его к промпту
    const finalPrompt = referenceImagePrompt 
      ? `${prompt}\n\nДОПОЛНИТЕЛЬНО: ${referenceImagePrompt}`
      : prompt;

    console.log('[Gemini] Generating creative image with Gemini 3 Pro Image Preview...');
    console.log('[Gemini] Final image prompt length:', finalPrompt.length);
    console.log('[Gemini] Has reference image:', hasReferenceImage);

    // Используем Gemini 3 Pro Image Preview для генерации изображений
    const client = getGeminiClient();
    const model = client.getGenerativeModel({
      model: 'gemini-3-pro-image-preview'
    });

    // Формируем массив частей контента
    const contentParts: any[] = [];

    // Добавляем текстовый промпт
    contentParts.push({ text: finalPrompt });

    // Добавляем референсное изображение, если оно есть
    if (referenceImage) {
      if (referenceImageType === 'url') {
        // Если URL, скачиваем изображение
        console.log('[Gemini] Fetching reference image from URL...');
        const response = await fetch(referenceImage);
        const buffer = await response.arrayBuffer();
        const base64 = Buffer.from(buffer).toString('base64');

        contentParts.push({
          inlineData: {
            mimeType: response.headers.get('content-type') || 'image/jpeg',
            data: base64
          }
        });
        console.log('[Gemini] Reference image fetched and added');
      } else {
        // Если уже base64
        contentParts.push({
          inlineData: {
            mimeType: 'image/jpeg',
            data: referenceImage
          }
        });
        console.log('[Gemini] Reference image (base64) added');
      }
    }

    // Конфигурация для генерации в формате 4:5
    // Генерируем в 4:5 - при upscale расширим до 9:16 (достроим снизу)
    // Это позволяет Meta корректно кропать 9:16 → 4:5 для Feed плейсментов
    const generationConfig = {
      responseModalities: ['IMAGE'],
      imageConfig: {
        aspectRatio: '4:5',
        imageSize: '2K'
      },
      temperature: 1.0,
      topK: 40,
      topP: 0.95
    };

    console.log('[Gemini] Image config: 4:5 aspect ratio, 2K resolution');

    const result = await model.generateContent({
      contents: [{ role: 'user', parts: contentParts }],
      generationConfig
    });
    const response = result.response;

    // Gemini возвращает изображение в base64
    if (!response.candidates || response.candidates.length === 0) {
      throw new Error('No image generated by Gemini');
    }

    const candidate = response.candidates[0];
    
    // Извлекаем изображение из ответа
    if (!candidate.content || !candidate.content.parts || candidate.content.parts.length === 0) {
      throw new Error('No image parts in response');
    }

    const imagePart = candidate.content.parts.find((part: any) => part.inlineData);
    
    if (!imagePart || !imagePart.inlineData || !imagePart.inlineData.data) {
      throw new Error('No image data in response');
    }

    const base64Image = imagePart.inlineData.data;

    console.log('[Gemini] Creative image generated successfully');
    console.log('[Gemini] Image size:', base64Image.length, 'bytes (base64)');
    
    return base64Image;
  } catch (error: any) {
    console.error('[Gemini] Error generating creative image:', error);
    throw new Error(`Gemini image generation failed: ${error.message}`);
  }
}

/**
 * Upscale изображения с 2K до 4K
 * Используется перед финальным сохранением/скачиванием
 * @param base64Image - Исходное изображение в base64
 * @param originalPrompt - Оригинальный промпт для сохранения стиля
 * @returns Base64 изображение в 4K качестве
 */
export async function upscaleImageTo4K(
  base64Image: string,
  originalPrompt: string,
  aspectRatio: '9:16' | '4:5' | '1:1' = '9:16' // Дефолт для одиночных креативов
): Promise<string> {
  try {
    console.log('[Gemini Upscale] Starting image upscale to 4K...');
    console.log('[Gemini Upscale] Aspect ratio:', aspectRatio);

    const client = getGeminiClient();
    const model = client.getGenerativeModel({
      model: 'gemini-3-pro-image-preview'
    });

    // Формируем контент с исходным изображением
    const contentParts: any[] = [
      {
        text: `${originalPrompt}\n\nУлучши качество этого изображения, сохранив все детали, композицию и стиль без изменений.`
      },
      {
        inlineData: {
          mimeType: 'image/jpeg',
          data: base64Image
        }
      }
    ];

    // Конфигурация для 4K
    const generationConfig = {
      responseModalities: ['IMAGE'],
      imageConfig: {
        aspectRatio: aspectRatio,
        imageSize: '4K'
      },
      temperature: 0.1, // Низкая температура для точного воспроизведения
      topK: 10,
      topP: 0.8
    };

    console.log('[Gemini Upscale] Generating 4K version...');

    const result = await model.generateContent({
      contents: [{ role: 'user', parts: contentParts }],
      generationConfig
    });

    const response = result.response;

    if (!response.candidates || response.candidates.length === 0) {
      throw new Error('No image generated during upscale');
    }

    const candidate = response.candidates[0];

    if (!candidate.content || !candidate.content.parts || candidate.content.parts.length === 0) {
      throw new Error('No image parts in upscale response');
    }

    const imagePart = candidate.content.parts.find((part: any) => part.inlineData);

    if (!imagePart || !imagePart.inlineData || !imagePart.inlineData.data) {
      throw new Error('No image data in upscale response');
    }

    const upscaledImage = imagePart.inlineData.data;

    console.log('[Gemini Upscale] 4K image generated successfully');
    console.log('[Gemini Upscale] Image size:', upscaledImage.length, 'bytes (base64)');

    return upscaledImage;
  } catch (error: any) {
    console.error('[Gemini Upscale] Error upscaling image:', error);
    throw new Error(`Image upscale failed: ${error.message}`);
  }
}

/**
 * Расширение изображения из 4:5 до 9:16
 * Достраивает фон СНИЗУ, сохраняя весь контент 4:5 в верхней части
 * @param base64Image - Исходное изображение в base64 (4:5)
 * @param originalPrompt - Оригинальный промпт для сохранения стиля
 * @returns Base64 изображение в 4K с aspect ratio 9:16
 */
export async function expandTo9x16(
  base64Image: string,
  originalPrompt: string
): Promise<string> {
  try {
    console.log('[Gemini Expand] Starting image expansion from 4:5 to 9:16...');

    const client = getGeminiClient();
    const model = client.getGenerativeModel({
      model: 'gemini-3-pro-image-preview'
    });

    // Промпт для outpainting - бесшовное расширение фона
    const expandPrompt = `SEAMLESS OUTPAINTING: Extend this 4:5 image to 9:16 by continuing the background.

CRITICAL: This is OUTPAINTING - you must generate MORE of the SAME background above and below the image.

The original image has a background (gradient, color, texture, pattern, or scene).
Your job is to SEAMLESSLY CONTINUE that exact same background in the new vertical space.

REQUIREMENTS:
1. KEEP the original image EXACTLY as-is in the CENTER
2. EXTEND the background UPWARD - analyze the top edge pixels and generate matching continuation
3. EXTEND the background DOWNWARD - analyze the bottom edge pixels and generate matching continuation
4. NO VISIBLE SEAMS - the transition must be INVISIBLE, like the background was always larger
5. MATCH everything: colors, gradients, lighting, texture, blur level, grain

TECHNICAL:
- If the top has a blue gradient → continue that blue gradient upward with the same direction
- If the bottom has a blurred background → continue that same blur level
- If there's a pattern → continue the pattern seamlessly
- The edges of the original must BLEND PERFECTLY into the new areas

DO NOT:
- Move, resize, or modify ANY content from the original image
- Add new objects, text, or elements to the extended areas
- Create any visible line, border, or color shift at the original edges
- Change the original image in any way

The result should look like ONE seamless image that was always 9:16, not a 4:5 image with added borders.`;

    const contentParts: any[] = [
      { text: expandPrompt },
      {
        inlineData: {
          mimeType: 'image/jpeg',
          data: base64Image
        }
      }
    ];

    // Конфигурация для 4K с aspect ratio 9:16
    const generationConfig = {
      responseModalities: ['IMAGE'],
      imageConfig: {
        aspectRatio: '9:16',
        imageSize: '4K'
      },
      temperature: 0.2, // Низкая температура для точного следования оригиналу
      topK: 20,
      topP: 0.8
    };

    console.log('[Gemini Expand] Generating 9:16 version with extended background...');

    const result = await model.generateContent({
      contents: [{ role: 'user', parts: contentParts }],
      generationConfig
    });

    const response = result.response;

    if (!response.candidates || response.candidates.length === 0) {
      throw new Error('No image generated during expansion');
    }

    const candidate = response.candidates[0];

    if (!candidate.content || !candidate.content.parts || candidate.content.parts.length === 0) {
      throw new Error('No image parts in expansion response');
    }

    const imagePart = candidate.content.parts.find((part: any) => part.inlineData);

    if (!imagePart || !imagePart.inlineData || !imagePart.inlineData.data) {
      throw new Error('No image data in expansion response');
    }

    const expandedImage = imagePart.inlineData.data;

    console.log('[Gemini Expand] 9:16 image generated successfully');
    console.log('[Gemini Expand] Image size:', expandedImage.length, 'bytes (base64)');

    return expandedImage;
  } catch (error: any) {
    console.error('[Gemini Expand] Error expanding image:', error);
    throw new Error(`Image expansion failed: ${error.message}`);
  }
}

/**
 * OCR - извлечение текста из изображения через Gemini Vision
 * @param imageUrl - URL изображения или base64
 * @param imageType - Тип: 'url' или 'base64'
 * @returns Извлечённый текст
 */
export async function extractTextFromImage(
  imageUrl: string,
  imageType: 'url' | 'base64' = 'url'
): Promise<string> {
  try {
    console.log('[Gemini OCR] Starting text extraction...');
    console.log('[Gemini OCR] Image type:', imageType);

    const client = getGeminiClient();
    // Используем gemini-2.0-flash для OCR
    const model = client.getGenerativeModel({
      model: 'gemini-2.0-flash'
    });

    // Формируем контент
    const contentParts: any[] = [];

    // Добавляем промпт для OCR
    contentParts.push({
      text: `Внимательно проанализируй это изображение рекламного креатива.

Твоя задача - извлечь ВЕСЬ текст, который виден на изображении:
- Заголовки и подзаголовки
- Основной текст
- Call-to-action (кнопки, призывы к действию)
- Мелкий текст (дисклеймеры, условия)
- Текст на продуктах, если виден
- Любые надписи и логотипы

Верни ТОЛЬКО извлечённый текст, без комментариев и пояснений.
Если текста нет - верни пустую строку.
Сохраняй структуру текста (переносы строк между блоками).`
    });

    // Добавляем изображение
    if (imageType === 'url') {
      console.log('[Gemini OCR] Fetching image from URL...');
      const response = await fetch(imageUrl);
      if (!response.ok) {
        throw new Error(`Failed to fetch image: ${response.statusText}`);
      }
      const buffer = await response.arrayBuffer();
      const base64 = Buffer.from(buffer).toString('base64');
      const mimeType = response.headers.get('content-type') || 'image/jpeg';

      contentParts.push({
        inlineData: {
          mimeType,
          data: base64
        }
      });
      console.log('[Gemini OCR] Image fetched, size:', base64.length, 'bytes');
    } else {
      // Уже base64
      contentParts.push({
        inlineData: {
          mimeType: 'image/jpeg',
          data: imageUrl
        }
      });
    }

    const result = await model.generateContent({
      contents: [{ role: 'user', parts: contentParts }]
    });

    const response = result.response;
    const text = response.text() || '';

    console.log('[Gemini OCR] Text extracted successfully, length:', text.length);

    return text.trim();
  } catch (error: any) {
    console.error('[Gemini OCR] Error extracting text:', error);
    throw new Error(`OCR failed: ${error.message}`);
  }
}

/**
 * Инициализация и проверка доступности Gemini API
 */
export async function initializeGeminiImageAPI(): Promise<void> {
  try {
    console.log('[Gemini Image] Initializing API...');
    console.log('[Gemini Image] Model: gemini-3-pro-image-preview');
    console.log('[Gemini Image] OCR Model: gemini-2.0-flash');
    console.log('[Gemini Image] API initialized successfully');
  } catch (error: any) {
    console.error('[Gemini Image] Failed to initialize API:', error);
    throw new Error(`Gemini Image API initialization failed: ${error.message}`);
  }
}

