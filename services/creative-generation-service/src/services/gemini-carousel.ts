import { GoogleGenerativeAI } from '@google/generative-ai';
import { generateCarouselCardPrompt } from './carouselPromptGenerator';
import { upscaleImageTo4K } from './gemini-image';
import { CarouselVisualStyle } from '../types';

let genAI: GoogleGenerativeAI | null = null;

function getGeminiClient(): GoogleGenerativeAI {
  if (!genAI) {
    const apiKey = process.env.GEMINI_API_KEY;
    if (!apiKey) {
      throw new Error('GEMINI_API_KEY must be set in environment variables');
    }
    genAI = new GoogleGenerativeAI(apiKey);
  }
  return genAI;
}

/**
 * Генерирует одну карточку карусели
 * @param cardText - Текст для карточки
 * @param cardIndex - Индекс карточки (0-based)
 * @param totalCards - Общее количество карточек
 * @param userPrompt1 - PROMPT1 пользователя
 * @param visualStyle - Визуальный стиль карусели
 * @param customPrompt - Дополнительный промпт от пользователя (опционально)
 * @param styleReferenceImage - Референс для консистентности стиля (предыдущая карточка)
 * @param contentReferenceImage - Референс контента от пользователя (товар, персонаж и т.п.)
 * @returns Base64 изображение
 */
async function generateCarouselCard(
  cardText: string,
  cardIndex: number,
  totalCards: number,
  userPrompt1: string,
  visualStyle: CarouselVisualStyle,
  customPrompt?: string,
  styleReferenceImage?: string,
  contentReferenceImage?: string
): Promise<string> {
  try {
    console.log(`[Gemini Carousel] Generating card ${cardIndex + 1}/${totalCards}...`);
    console.log('[Gemini Carousel] Has style reference:', !!styleReferenceImage);
    console.log('[Gemini Carousel] Has content reference:', !!contentReferenceImage);

    // Генерируем промпт через LLM-агент
    const prompt = await generateCarouselCardPrompt(
      userPrompt1,
      cardText,
      cardIndex,
      totalCards,
      visualStyle,
      customPrompt
    );

    console.log('[Gemini Carousel] Generated prompt length:', prompt.length);

    const client = getGeminiClient();
    const model = client.getGenerativeModel({
      model: 'gemini-3-pro-image-preview'
    });

    // Формируем массив частей контента
    const contentParts: any[] = [];

    // Добавляем основной промпт
    contentParts.push({ text: prompt });

    // Добавляем референс контента (товар/персонаж от пользователя) — ПЕРВЫМ
    // Это то, что пользователь хочет ВИДЕТЬ на карточке
    if (contentReferenceImage) {
      console.log('[Gemini Carousel] Adding CONTENT reference (user product/asset)...');
      contentParts.push({
        text: '\n\n[РЕФЕРЕНС КОНТЕНТА - ВАЖНО!]\nЭто изображение показывает товар/объект/персонажа, который ОБЯЗАТЕЛЬНО должен быть размещён на карточке. Используй ИМЕННО этот объект как главный элемент изображения. Сохрани его внешний вид, форму и детали.'
      });
      contentParts.push({
        inlineData: {
          mimeType: 'image/jpeg',
          data: contentReferenceImage
        }
      });
    }

    // Добавляем референс стиля (предыдущая карточка) — ВТОРЫМ
    // Это для консистентности дизайна
    if (styleReferenceImage) {
      console.log('[Gemini Carousel] Adding STYLE reference (previous card)...');
      contentParts.push({
        text: '\n\n[РЕФЕРЕНС СТИЛЯ]\nЭто предыдущая карточка карусели. Используй её только для консистентности СТИЛЯ: той же палитры, типографики, композиции, расположения текста. НЕ копируй содержимое — создай НОВЫЙ кадр с ДРУГИМ ракурсом/действием, но в том же визуальном стиле.'
      });
      contentParts.push({
        inlineData: {
          mimeType: 'image/jpeg',
          data: styleReferenceImage
        }
      });
    }

    // Конфигурация для генерации в формате 1:1 для Instagram карусели
    const generationConfig = {
      responseModalities: ['IMAGE'],
      imageConfig: {
        aspectRatio: '1:1',
        imageSize: '2K'
      },
      temperature: 1.0,
      topK: 40,
      topP: 0.95
    };

    console.log('[Gemini Carousel] Calling Gemini API...');

    const result = await model.generateContent({
      contents: [{ role: 'user', parts: contentParts }],
      generationConfig
    });

    const response = result.response;

    if (!response.candidates || response.candidates.length === 0) {
      throw new Error('No image generated by Gemini');
    }

    const candidate = response.candidates[0];

    if (!candidate.content || !candidate.content.parts || candidate.content.parts.length === 0) {
      throw new Error('No image parts in response');
    }

    const imagePart = candidate.content.parts.find((part: any) => part.inlineData);

    if (!imagePart || !imagePart.inlineData || !imagePart.inlineData.data) {
      throw new Error('No image data in response');
    }

    const base64Image = imagePart.inlineData.data;

    console.log(`[Gemini Carousel] Card ${cardIndex + 1}/${totalCards} generated successfully`);
    console.log('[Gemini Carousel] Image size:', base64Image.length, 'bytes (base64)');

    return base64Image;

  } catch (error: any) {
    console.error(`[Gemini Carousel] Error generating card ${cardIndex + 1}:`, error);
    throw new Error(`Carousel card generation failed: ${error.message}`);
  }
}

/**
 * Генерирует все карточки карусели последовательно
 * Стратегия:
 * 1. Генерируем 1-ю карточку (только контент-референс от пользователя, если есть)
 * 2. Генерируем 2-ю карточку (контент-референс + карточка 0 как стиль-референс)
 * 3. Генерируем остальные карточки (контент-референс + карточка 1 как стиль-референс)
 *
 * @param carouselTexts - Массив текстов для карточек
 * @param userPrompt1 - PROMPT1 пользователя
 * @param visualStyle - Визуальный стиль карусели (по умолчанию 'clean_minimal')
 * @param customPrompts - Опциональные кастомные промпты для каждой карточки
 * @param referenceImages - Опциональные референсные изображения КОНТЕНТА для каждой карточки (base64)
 * @returns Массив base64 изображений
 */
export async function generateCarouselImages(
  carouselTexts: string[],
  userPrompt1: string,
  visualStyle: CarouselVisualStyle = 'clean_minimal',
  customPrompts?: (string | null)[],
  referenceImages?: (string | null)[]
): Promise<string[]> {
  try {
    console.log('[Gemini Carousel] Starting carousel generation...');
    console.log('[Gemini Carousel] Total cards:', carouselTexts.length);

    const generatedImages: string[] = [];
    const totalCards = carouselTexts.length;

    for (let i = 0; i < totalCards; i++) {
      const cardStartTime = Date.now();
      console.log(`[Gemini Carousel] Starting generation for card ${i + 1}/${totalCards}...`);

      const cardText = carouselTexts[i];
      const customPrompt = customPrompts?.[i] || undefined;

      // Референс КОНТЕНТА от пользователя (товар, персонаж и т.п.) — только для этой карточки
      const contentReference = referenceImages?.[i] || undefined;

      // Референс СТИЛЯ (предыдущая сгенерированная карточка) — для консистентности дизайна
      let styleReference: string | undefined;
      if (i === 1 && generatedImages.length >= 1) {
        // Вторая карточка: используем первую как референс стиля
        styleReference = generatedImages[0];
      } else if (i >= 2 && generatedImages.length >= 2) {
        // Третья и последующие: используем вторую как референс стиля
        styleReference = generatedImages[1];
      }

      const image = await generateCarouselCard(
        cardText,
        i,
        totalCards,
        userPrompt1,
        visualStyle,
        customPrompt,
        styleReference,
        contentReference
      );

      generatedImages.push(image);

      const cardEndTime = Date.now();
      const cardDuration = ((cardEndTime - cardStartTime) / 1000).toFixed(2);
      console.log(`[Gemini Carousel] Card ${i + 1}/${totalCards} generated in ${cardDuration}s`);

      // Небольшая пауза между генерациями, чтобы не перегрузить API
      if (i < totalCards - 1) {
        await new Promise(resolve => setTimeout(resolve, 1000));
      }
    }

    console.log('[Gemini Carousel] All cards generated successfully');
    return generatedImages;

  } catch (error: any) {
    console.error('[Gemini Carousel] Error generating carousel:', error);
    throw new Error(`Carousel generation failed: ${error.message}`);
  }
}

/**
 * Перегенерирует одну карточку в существующей карусели
 * @param cardText - Текст для карточки
 * @param cardIndex - Индекс карточки (0-based)
 * @param existingImages - Существующие изображения карусели (base64)
 * @param userPrompt1 - PROMPT1 пользователя
 * @param visualStyle - Визуальный стиль карусели (по умолчанию 'clean_minimal')
 * @param customPrompt - Дополнительный промпт от пользователя
 * @param contentReferenceImage - Референс контента от пользователя (товар, персонаж и т.п.)
 * @returns Base64 изображение
 */
export async function regenerateCarouselCard(
  cardText: string,
  cardIndex: number,
  existingImages: string[],
  userPrompt1: string,
  visualStyle: CarouselVisualStyle = 'clean_minimal',
  customPrompt?: string,
  contentReferenceImage?: string
): Promise<string> {
  try {
    console.log(`[Gemini Carousel] Regenerating card ${cardIndex + 1}...`);
    console.log('[Gemini Carousel] Has content reference from user:', !!contentReferenceImage);

    const totalCards = existingImages.length;

    // Референс СТИЛЯ — берём из существующих карточек для консистентности
    // Но ТОЛЬКО если это не первая карточка (для первой нет смысла брать референс стиля)
    let styleReference: string | undefined;
    if (cardIndex === 0) {
      // Первая карточка: не используем референс стиля — она сама задаёт стиль
      styleReference = undefined;
    } else if (cardIndex === 1 && existingImages.length >= 1) {
      // Вторая карточка: используем первую как референс стиля
      styleReference = existingImages[0];
    } else if (cardIndex >= 2 && existingImages.length >= 2) {
      // Третья и далее: используем вторую карточку как референс стиля
      styleReference = existingImages[1];
    }

    const image = await generateCarouselCard(
      cardText,
      cardIndex,
      totalCards,
      userPrompt1,
      visualStyle,
      customPrompt,
      styleReference,
      contentReferenceImage
    );

    console.log(`[Gemini Carousel] Card ${cardIndex + 1} regenerated successfully`);
    return image;

  } catch (error: any) {
    console.error(`[Gemini Carousel] Error regenerating card ${cardIndex + 1}:`, error);
    throw new Error(`Card regeneration failed: ${error.message}`);
  }
}

/**
 * Upscale всех карточек карусели до 4K
 * @param images - Массив изображений в 2K (base64)
 * @param prompts - Массив промптов, использованных для генерации (для сохранения стиля)
 * @returns Массив upscaled изображений в 4K (base64)
 */
export async function upscaleCarouselTo4K(
  images: string[],
  prompts: string[]
): Promise<string[]> {
  try {
    console.log('[Gemini Carousel Upscale] Starting upscale to 4K...');
    console.log('[Gemini Carousel Upscale] Total images:', images.length);

    const upscaledImages: string[] = [];

    for (let i = 0; i < images.length; i++) {
      console.log(`[Gemini Carousel Upscale] Upscaling image ${i + 1}/${images.length}...`);

      const upscaledImage = await upscaleImageTo4K(
        images[i],
        prompts[i] || 'Premium минималистичный рекламный креатив',
        '1:1' // Карусель в формате 1:1
      );

      upscaledImages.push(upscaledImage);

      // Пауза между upscale
      if (i < images.length - 1) {
        await new Promise(resolve => setTimeout(resolve, 1000));
      }
    }

    console.log('[Gemini Carousel Upscale] All images upscaled successfully');
    return upscaledImages;

  } catch (error: any) {
    console.error('[Gemini Carousel Upscale] Error upscaling carousel:', error);
    throw new Error(`Carousel upscale failed: ${error.message}`);
  }
}
